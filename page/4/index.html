<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | @chaoming.edc blog</title>
  <meta name="author" content="chaoming.edc|blastmann">
  
  <meta name="description" content="track my learning">
  
  
  <meta name="keywords" content="windowsphone,windows,xaml,developer,iOS,OSX,productive">
  
  

  

  <meta property="og:site_name" content="@chaoming.edc blog"/>
  <meta name="copyright" content="@chaoming.edc blog"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <meta name="google-site-verification" content="nTpmJEYYJgba5eVrpd_dfj1W_Ayr-NjZ1vFvhi5aqzI" />
   <meta name="baidu-site-verification" content="QO84kHVH0w" />
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.png" >
   <link rel="alternate" href="http://blog.edi-c.com/atom.xml" title="@chaoming.edc blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">@chaoming.edc blog</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="/about/">About</a><li>
    
      <li class="cell"><a class="next" href="/atom.xml">Subscribe</a><li>
    
    </ul>
</nav>

  <div class="widget weibo">
<iframe width="100%" height="100" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=110&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=0&isWeibo=0&isFans=0&uid=newdings&verifier=78e1ee4d&colors=ffffff,ffffff,999,000,ecfbfd&dpc=1"></iframe>
</div>

  

  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/IE/" style="font-size: 10.00px;">IE</a><a href="/tags/Swift/" style="font-size: 10.00px;">Swift</a><a href="/tags/WPF/" style="font-size: 10.00px;">WPF</a><a href="/tags/alfred/" style="font-size: 10.00px;">alfred</a><a href="/tags/aspnet/" style="font-size: 10.00px;">aspnet</a><a href="/tags/browser/" style="font-size: 10.00px;">browser</a><a href="/tags/csharp/" style="font-size: 10.00px;">csharp</a><a href="/tags/css3/" style="font-size: 12.00px;">css3</a><a href="/tags/dev/" style="font-size: 10.00px;">dev</a><a href="/tags/diary/" style="font-size: 10.00px;">diary</a><a href="/tags/directx/" style="font-size: 10.00px;">directx</a><a href="/tags/fiddler/" style="font-size: 12.00px;">fiddler</a><a href="/tags/google/" style="font-size: 10.00px;">google</a><a href="/tags/iOS/" style="font-size: 10.00px;">iOS</a><a href="/tags/ie/" style="font-size: 10.00px;">ie</a><a href="/tags/ie11/" style="font-size: 10.00px;">ie11</a><a href="/tags/javascript/" style="font-size: 10.00px;">javascript</a><a href="/tags/mac/" style="font-size: 10.00px;">mac</a><a href="/tags/markdown/" style="font-size: 10.00px;">markdown</a><a href="/tags/mvc/" style="font-size: 10.00px;">mvc</a><a href="/tags/note/" style="font-size: 10.00px;">note</a><a href="/tags/notes/" style="font-size: 16.00px;">notes</a><a href="/tags/plugin/" style="font-size: 10.00px;">plugin</a><a href="/tags/productivity/" style="font-size: 10.00px;">productivity</a><a href="/tags/programming/" style="font-size: 12.00px;">programming</a><a href="/tags/python/" style="font-size: 10.00px;">python</a><a href="/tags/reflow/" style="font-size: 10.00px;">reflow</a><a href="/tags/st2/" style="font-size: 16.00px;">st2</a><a href="/tags/summaries/" style="font-size: 10.00px;">summaries</a><a href="/tags/system/" style="font-size: 10.00px;">system</a><a href="/tags/vim/" style="font-size: 10.00px;">vim</a><a href="/tags/vs2012/" style="font-size: 10.00px;">vs2012</a><a href="/tags/web/" style="font-size: 10.00px;">web</a><a href="/tags/webdev/" style="font-size: 20.00px;">webdev</a><a href="/tags/webview/" style="font-size: 10.00px;">webview</a><a href="/tags/windows/" style="font-size: 14.00px;">windows</a><a href="/tags/winrt/" style="font-size: 12.00px;">winrt</a><a href="/tags/workflow/" style="font-size: 10.00px;">workflow</a><a href="/tags/wp/" style="font-size: 10.00px;">wp</a><a href="/tags/wp8/" style="font-size: 18.00px;">wp8</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2014 chaoming.edc|blastmann
  
</div>



<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51731334-1', 'edi-c.com');
  ga('send', 'pageview');

</script></footer>
    </aside>


    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">@chaoming.edc blog</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/PRO-WPF-NOTES-002.html">WPF 学习笔记（二）——控件模板</a></h1>
  

      <time datetime="2013-03-08T02:52:00.000Z"><a href="/post/PRO-WPF-NOTES-002.html">3月 8 2013</a></time>
      
  </header>
    <div class="entry">
      
        <h2 id="理解逻辑树和可视化树">理解逻辑树和可视化树</h2>
<p>在 XAML 中添加的元素的分类被称为逻辑树，编程人员需要花费大部分时间构建逻辑树，然后使用事件处理代码支持它们。实际上，到目前为止介绍的所有 WPF 特性（如属性值继承、事件路由以及样式）都是通过逻辑树进行工作的。</p>
<p>可视化树是逻辑树的扩展版本，它将元素分成更小的部分。</p>
<h2 id="理解模板">理解模板</h2>
<h3 id="控件如何从逻辑树表示扩展成可视化树？">控件如何从逻辑树表示扩展成可视化树？</h3>
<p>每个控件都有一个内置的方法，用于确定如何渲染控件（作为一组更基础的元素）。该方法称为控件模板（Control Template），是用 XAML 标记块定义的。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 3月 8 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/PRO-WPF-NOTES-001.html">WPF 学习笔记（一）——动画</a></h1>
  

      <time datetime="2013-03-07T02:52:00.000Z"><a href="/post/PRO-WPF-NOTES-001.html">3月 7 2013</a></time>
      
  </header>
    <div class="entry">
      
        <h2 id="故事板">故事板</h2>
<ul>
<li><strong>故事板</strong>是 <code>BeginAnimation()</code> 的 XAML 等价物，可以通过故事板将动画指定到合适的元素和属性。</li>
<li><strong>事件触发器</strong>。事件触发器响应属性变化或事件，并且控制故事板。</li>
</ul>
<h2 id="动画性能">动画性能</h2>
<h3 id="帧速率">帧速率</h3>
<p>目标：要保持 60 FPS。<br>要显式限制 FPS，需要对 Storyboard 直接声明：</p>
<pre><code>&lt;Storyboard Timeline<span class="preprocessor">.DesiredFrameRate</span> = <span class="string">"30"</span>&gt;
</code></pre><p>另外，点击 <a href="http://blogs.msdn.com/b/henryh/archive/2006/08/23/719568.aspx" target="_blank">此网址</a> 可以查看一个动画帧速帮助类。该示例演示了如何根据显卡的渲染级别显式地降低帧速率。</p>
<h3 id="位图缓存">位图缓存</h3>
<p>对于复杂的 Path 内容，可以对其启用 BitmapCache，将渲染完成的内容以位图的形式发送至显卡中，减低 CPU 占用率。下面的三点指导原则：</p>
<ul>
<li>如果正在绘制的内容需要频繁地重新绘制，使用位图缓存是合理的。</li>
<li>如果元素的内容经常变化，使用位图缓存可能不合理。因为可视化内容每次改变时，WPF 需要重新渲染位图并将其发送到显卡缓存，而这需要时间。</li>
<li>尽可能降低缓存内容的数量。位图越大，WPF 存储缓存备份所需要的时间越长，并且需要的显存越多。</li>
</ul>
<h4 id="性能分析工具_Perforator">性能分析工具 <a href="http://tinyurl.com/yfqottg" target="_blank">Perforator</a></h4>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 3月 7 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/2013-feb-summary.html">2013 年 2 月小结</a></h1>
  

      <time datetime="2013-02-28T11:30:00.000Z"><a href="/post/2013-feb-summary.html">2月 28 2013</a></time>
      
  </header>
    <div class="entry">
      
        <h2 id="2013_年_2_月小结">2013 年 2 月小结</h2>
<p>2 月份一转眼就过去了，由于 2 月初的时候基本上就是处于准备放假的状态，因此有种随大队的感觉，一直没有什么动力去好好工作。闲了一个星期左右，人都基本走光光了，于是便开始放春假假期。</p>
<p>2 月份过得很快，基本上春节假期过完之后，再过两周就完了。两周可以做些什么呢？下面过一下流水帐。</p>
<h2 id="学习">学习</h2>
<p>越来越觉得自己学习没有时间（真的是没有时间吗？感觉回家之后都在浪费时间），这个月浪费了不少时间来看小说，例如：回顾了一下《三国演义》之类的历史类小说。</p>
<h3 id="读了什么书？">读了什么书？</h3>
<p>这个月还是读了一点点书的，把 Kindle 卖掉之后，花了点钱收了一台 iPad Mini。于是把之前没有看的 PDF 都扔进去了。PDF 什么的都是工具书，看起来都很吃力，而且自己也没有做什么 Demo 之类的，陷入恶性循环中。</p>
<p>这个月读了重新读了一点点《HTTP 权威指南》，书是很不错，不过读起来真的有点难熬，看了半个月都只是看了 100 页不到，真需要一本计算机类的词典。</p>
<h4 id="HTTP_权威指南阅读整理">HTTP 权威指南阅读整理</h4>
<p>下面简单记录一下一些感觉比较有需要的关键字：</p>
<ul>
<li>URIs 、URLs 和 URNs 及其语法</li>
<li>HTTP 方法</li>
<li>HTTP 消息组成</li>
<li>HTTP 状态码</li>
</ul>
<p>具体的脑图什么的，晚点再整理一下吧。</p>
<h2 id="工作">工作</h2>
<p>本月工作仍然是集中在 Webkit 的移植上面。在手机上面的调试仍然很头痛，我是属于基本上帮不上忙的那种，只能自己折腾自己改过的代码。</p>
<h3 id="DirectX">DirectX</h3>
<p>这东西真的是很难搞，小弟真心搞不懂这东西，为了显示一个纹理花了好几份代码去做显示。感觉到时如果微软开放了一些 2D 引擎接口的话，现在做的事情就是有点浪费时间了（其实 D2D 什么的也有开放，只是一般人不能用而已）。</p>
<h5 id="马克一点点东西">马克一点点东西</h5>
<p>搞了那么久的 DirectX，实质上理解的东西真的是很少，自己了解的东西也只有纹理渲染那一点点内容了。对于其本质以及 GPU 的调度之类的理解十分少。折腾了好久的自家用 DX 显示引擎也只是简单地调用几个 API 拼凑出来的东西，真心觉得性能低下。</p>
<ul>
<li>UpdateSubresource，Map/Unmap 和 CopySubresourceRegion 等更新纹理的方法，性能上的差别似乎不怎么明显，估计是测试工程中的 GPU 运算量并不大。</li>
<li>Draw、DrawIndexed 两个绘制方法的区别（似乎是跟图元分割有关系，现在只知道我用后面一个来绘制 2D 纹理的话将无法显示内容）</li>
</ul>
<h3 id="线程处理">线程处理</h3>
<p>多线程处理又是另外一个让人头大的东西。</p>
<ul>
<li>TLS的实现，主要是为了解决多线程共享数据，不同的算法实际出来的性能也有很大差异</li>
<li>多线程编程下，尽可能少锁，提高性能（这话谁都会说，到底怎么设计啊？）</li>
</ul>
<p>近来的工作真是一点进展都没有，没啥好总结的，还是抽空看完《HTTP 权威指南》再说吧。</p>
<h2 id="未来展望">未来展望</h2>
<p>展望一下，感觉要撑过今年真的是有点难度。现在才 3 月份刚开始，导师已经决定月底就要走人了，反正感觉最近的工作气氛不怎么好，自己也没有什么动力去干活。</p>
<p>3 月份，可以看完《HTTP 权威指南》吗？最好就是可以列出一些重点内容，同时写一些 Demo，增加一点点经验。</p>
<p>月底要去泰国旅游，又是花钱，哎~</p>
<p>（完）</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 2月 28 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/how-to-create-a-st2-plugin.html">如何编写一个 Sublime Text 2 插件</a></h1>
  

      <time datetime="2013-02-05T01:35:00.000Z"><a href="/post/how-to-create-a-st2-plugin.html">2月 5 2013</a></time>
      
  </header>
    <div class="entry">
      
        <p>最近折腾了一个调用 ScriptOgr.am 的 API 发布博客文章的小插件，主要是参考了 Prefixr 这个插件编写而成的。在编写过程中算是把 Python 这东西入门了一点，下面总结一点东西，分享。</p>
<p>网上关于如何编写 ST2 插件的文章：<a href="http://net.tutsplus.com/tutorials/python-tutorials/how-to-create-a-sublime-text-2-plugin/" target="_blank">点击进入</a></p>
<p>下面的代码内容托管在我的 Github 上，有兴趣可以<a href="https://github.com/blastmann/ScriptOgrSender" target="_blank">点击这里</a>。</p>
<h2 id="Step_1:_创建一个新的插件">Step 1: 创建一个新的插件</h2>
<p>创建新插件的步骤很简单，只需要点击菜单栏上的 Tools-&gt;New Plugin.. 即可，ST2将自动创建一个简单的插件模板，代码如下：</p>
<pre><code><span class="keyword">import</span> sublime, sublime_plugin
<span class="class"><span class="keyword">class</span> <span class="title">ExampleCommand</span><span class="params">(sublime_plugin.TextCommand)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, edit)</span>:</span>
        self.view.insert(edit, <span class="number">0</span>, <span class="string">"Hello, World!"</span>)
</code></pre><p>在 Packages 文件夹里面，创建一个属于你自己的插件名字的文件夹，然后将代码保存到其中，即可以在 Console 中运行下面的命令：</p>
<pre><code>view.run_command(<span class="string">'example'</span>)
</code></pre><p>命令运行完成后，当前窗口将自动插入一行字符 “Hello, World!”。恭喜你，插件的编写就是这么简单。</p>
<h2 id="Step_2:_命令类型及其命名">Step 2: 命令类型及其命名</h2>
<p>关于 Sublime Text 2 中的命令类型，本人通过查找 <code>sublime_plugin.py</code> 中定义的类，大概知道有下面几种：</p>
<ul>
<li>Application Command - 调用 ST2 本身的程序命令</li>
<li>Window Command - 对应当前窗口的命令</li>
<li>Text Command - 文字处理型命令</li>
</ul>
<p>在创建属于我们自己的插件时，我们可能需要继承上面列出的几种命令中的其中一种或多种来实现我们自己的功能。</p>
<p>关于插件中的命令命名，我们在定义自己的插件命令时，需要注意以下格式：</p>
<ul>
<li>命令需要通过定义类来声明，命令类至少需要继承上面的三种命令这一</li>
<li>类的名称中以 <code>Command</code> 来结尾，<code>Command</code> 前的名称即为命令的名称</li>
<li>命令名称需要注意使用驼峰式命名，在 Sublime Text 2 中，驼峰式命名将转换为通过下划线 <code>_</code> 分隔的命名。例如：<code>TextSelectCommand</code> 最后将转换为 <code>text_select</code>。</li>
</ul>
<h2 id="Step_3:_线程">Step 3: 线程</h2>
<p>在我的插件里面，需要通过 HTTP 来提交属于博客文章内容。如果在主线程中创建 HTTP Post 请求的话，整个 Sublime Text 将会失去响应，直到请求完成。因此我们需要将请求代码放到另外一个单独的线程中进行。</p>
<pre><code><span class="keyword">thread</span> <span class="subst">=</span> ScriptOgrApiCall(filename, content, <span class="string">'post'</span>, <span class="built_in">self</span><span class="built_in">.</span>user_id, <span class="built_in">self</span><span class="built_in">.</span>proxy_server, <span class="number">500</span>)
threads<span class="built_in">.</span>append(<span class="keyword">thread</span>)
<span class="keyword">thread</span><span class="built_in">.</span>start()
</code></pre><p>创建线程后，HTTP 请求将在后台进行，减轻对主界面的影响。</p>
<h2 id="Step_4:_创建线程">Step 4: 创建线程</h2>
<p>为了将我们需要提交的内容放置到单独的线程中，我创建了一个单独的 ApiCall 类，负责接收请求的内容。</p>
<p>线程初始化时，我定义了好几个参数以传入线程中进行处理，参数基本对应 ScriptOgr.am 中的 API 请求而制定的：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ScriptOgrApiCall</span><span class="params">(threading.Thread)</span>:</span>
    <span class="string">"""docstring for ScriptOgrApiCall"""</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, filedata, operation, user_id, proxy_server, timeout)</span>:</span>
        threading.Thread.__init__(self)
        self.filename  = filename
        self.filedata  = filedata
        self.operation = operation
        self.timeout   = timeout
        self.user_id   = user_id
        self.proxy     = proxy_server
        self.response  = <span class="keyword">None</span>
        self.result    = <span class="keyword">None</span>
</code></pre><p>下面就是在此类中创建不同函数以适应调用需要，具体代码不再列出。</p>
<h2 id="Step_5:_结果处理">Step 5: 结果处理</h2>
<p>线程执行完毕后，我将服务器返回的 JSON 解析后输出赋予线程中的 response 属性。解析 JSON 时使用的是 Python 自带的 JSON 模块。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">parse_response</span><span class="params">(self)</span>:</span>
    response = json.loads(self.response)
    <span class="keyword">if</span> response[<span class="string">'status'</span>] == <span class="string">'success'</span>:
        <span class="keyword">if</span> self.operation == <span class="string">'post'</span>:
            self.response = <span class="string">'Successfully post your article'</span>
        <span class="keyword">elif</span> self.operation == <span class="string">'delete'</span>:
            self.response = <span class="string">'Successfully delete your article'</span>
    <span class="keyword">elif</span> response[<span class="string">'status'</span>] == <span class="string">'failed'</span>:
        self.response = response[<span class="string">'reason'</span>]
</code></pre><h2 id="Step_6:_管理线程">Step 6: 管理线程</h2>
<p>在创建自己的命令时，我先行创建一个命令基类，定义一些需要重复使用的函数：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ScriptOgrCommandBase</span><span class="params">(sublime_plugin.TextCommand)</span>:</span>
    <span class="string">"""docstring for CommandBase"""</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, view)</span>:</span>
        <span class="comment"># Inherit from class TextCommand</span>
        sublime_plugin.TextCommand.__init__(self, view)
</code></pre><p>创建好基类后，定义一个线程管理类，负责监控线程的运行情况，如线程完成后，则打印出服务器返回的信息：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">handle_threads</span><span class="params">(self, threads, i=<span class="number">0</span>, dir=<span class="number">0</span>)</span>:</span>
    next_threads = []
    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:
        <span class="keyword">if</span> thread.is_alive():
            next_threads.append(thread)
        <span class="keyword">else</span>:
            <span class="keyword">print</span> <span class="string">'\nScriptOgr.am api response: '</span> + thread.get_response() + <span class="string">'\n'</span>
            sublime.status_message(<span class="string">'ScriptOgr.am api response: '</span> + thread.get_response())
        <span class="keyword">if</span> thread.result == <span class="keyword">False</span>:
            <span class="keyword">continue</span>
    threads = next_threads

    <span class="keyword">if</span> len(threads):
        before = i % <span class="number">8</span>
        after = (<span class="number">7</span>) - before
        <span class="keyword">if</span> <span class="keyword">not</span> after:
            dir = -<span class="number">1</span>
        <span class="keyword">if</span> <span class="keyword">not</span> before:
            dir = <span class="number">1</span>
        i += dir
        self.view.set_status(<span class="string">'operating'</span>, <span class="string">'ScriptOgrSender is opearting [%s=%s]'</span> % \
            (<span class="string">' '</span> * before, <span class="string">' '</span> * after))

        sublime.set_timeout(<span class="keyword">lambda</span>: self.handle_threads(threads, i, dir), <span class="number">100</span>)
        <span class="keyword">return</span>
    self.view.erase_status(<span class="string">'operating'</span>)
</code></pre><p>其中调用了一些 ST2 本身提供的 API，如 <code>set_status</code>、<code>erase_status</code> 等，用于将信息更新至 ST2 窗口下方的状态栏中。</p>
<h2 id="Step_7:_插件配置文件">Step 7: 插件配置文件</h2>
<p>很多插件都会自带一个配置文件（以 <code>.sublime-settings</code> 后缀结尾的文件），用以配置用户的参数，我们也可以将一些有可能修改的字段定义在插件配置文件中，日后便不用修改代码，直接修改配置文件即可。</p>
<p>下面是我的配置文件示例（JSON格式）：</p>
<pre><code>/* <span class="type">ScriptOgr</span> <span class="default"><span class="keyword">default</span> setting */</span>
{
    <span class="string">"proxy_server"</span> : <span class="string">""</span>,
    <span class="string">"user_id"</span> : <span class="string">""</span>,
    <span class="string">"base_url"</span>: <span class="string">"http://scriptogr.am/api/article/"</span>
}
</code></pre><p>读取文件配置的代码如下，调用一下 Sublime Text 2 提供的 API 即可。</p>
<pre><code>settings = sublime.load_settings(<span class="string">'ScriptOgrSender.sublime-settings'</span>)
base_url = settings.<span class="keyword">get</span>(<span class="string">'base_url'</span>)
self.user_id = settings.<span class="keyword">get</span>(<span class="string">'user_id'</span>)
self.proxy_server = settings.<span class="keyword">get</span>(<span class="string">'proxy_server'</span>)
</code></pre><h2 id="Step_8:_快捷键绑定">Step 8: 快捷键绑定</h2>
<p>ST2 中的快捷键绑定可以说是最强大的功能之一了，其可定义性极高，只需要稍微理解一下示例中的定义即可创建出属于自己的快捷键绑定了。</p>
<p>ScriptOgrSender 中的快捷键绑定如下：</p>
<pre><code>[
    {
        "<span class="attribute">keys</span>": <span class="value">[<span class="string">"shift+alt+p"</span>]</span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"post_scr"</span></span>,
        "<span class="attribute">context</span>":
            <span class="value">[
                { "<span class="attribute">key</span>": <span class="value"><span class="string">"selector"</span></span>, "<span class="attribute">operator</span>": <span class="value"><span class="string">"equal"</span></span>, "<span class="attribute">operand</span>": <span class="value"><span class="string">"text.html.markdown"</span> </span>}
            ]
    </span>},
    {
        "<span class="attribute">keys</span>": <span class="value">[<span class="string">"shift+alt+d"</span>]</span>,
        "<span class="attribute">command</span>": <span class="value"><span class="string">"del_post_scr"</span></span>,
        "<span class="attribute">context</span>":
            <span class="value">[
                { "<span class="attribute">key</span>": <span class="value"><span class="string">"selector"</span></span>, "<span class="attribute">operator</span>": <span class="value"><span class="string">"equal"</span></span>, "<span class="attribute">operand</span>": <span class="value"><span class="string">"text.html.markdown"</span> </span>}
            ]
    </span>}
]
</code></pre><p>其中， <code>keys</code> 即需要绑定的快捷键组合，ST2 提供了 Ctrl\Alt\Shift\Super 等常用的辅助键定义（<code>Super</code> 即键盘上的 Windows 键，或者是 Mac OS X 中的 Command 键）， <code>command</code> 即快捷键对应的命令，其定义请参考本文第一步。 <code>context</code> 字段定义了一个快捷键启用的上下文，即只有在 <code>text.html.markdown</code> 格式中才启用上面的快捷键。</p>
<h2 id="Step_9:_添加菜单选项">Step 9: 添加菜单选项</h2>
<p>下面说一下菜单选项，如果需要在 <code>Preferences</code> 菜单中添加插件相关的配置菜单项，请自行添加一个 <code>Main.sublime-menu</code> 文件，用于定义主菜单项目。内容太长在文章中就不贴出来了，具体可以参考其他插件中的文件。</p>
<p>另外，需要在右键菜单中添加快捷选项的话，请添加一个 <code>Context.sublime-menu</code>，简单内容如下：</p>
<pre><code>[
    { "<span class="attribute">command</span>": <span class="value"><span class="string">"post_scr"</span></span>, "<span class="attribute">caption</span>": <span class="value"><span class="string">"Post to ScriptOgr.am"</span> </span>},
    { "<span class="attribute">command</span>": <span class="value"><span class="string">"del_post_scr"</span></span>, "<span class="attribute">caption</span>": <span class="value"><span class="string">"Delete this post on ScriptOgr.am"</span> </span>}
]
</code></pre><h2 id="Step_10:_发布你的插件包">Step 10: 发布你的插件包</h2>
<p>如果需要将你亲自编写的插件发布到 Package Control 上，可以参照官网上的说明（<a href="http://wbond.net/sublime_packages/package_control/package_developers" target="_blank">点击查看</a>）。</p>
<h2 id="开始编写属于你自己的插件吧！">开始编写属于你自己的插件吧！</h2>
<p>上面的内容都是兴趣使然的结果，本来对 Python 这语言也有一点点兴趣的我，由于没有什么实质的需求，一直没有怎么学习。通过自己编写这样的一个简单的小插件，感觉除了对 Python 语言本身熟悉一点点之外，还在过程中感受到之前的编程中没有使用过的小技巧的好处。感觉自己逐渐地对编程有点感觉了，不然也不会不停地去思考如何去增强代码的复用程度，精简代码中的冗余部分。</p>
<p>总的来说，自行去编写一个属于自己的插件这件事情，还是一件挺有意义的事情来的。一方面可以满足到自己的需求，另外一方面也可以锻炼到自己。另外， Sublime Text 3 已经发布测试版本了，平台也切换到 Python 3 了，到时还需要检查插件运行是否正常。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 2月 5 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/vs2012-tips.html">Visual Studio 2012 使用技巧记录</a></h1>
  

      <time datetime="2013-02-04T09:09:00.000Z"><a href="/post/vs2012-tips.html">2月 4 2013</a></time>
      
  </header>
    <div class="entry">
      
        <p>简单记录一下自己最近使用 VS 的时候了解到的一些简单技巧。</p>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>ctrl+shift+w - 选择当前光标所在的单词，自动匹配单词，如变量名称为 DrawingSurface 的时候，光标在 Drawing 之间，则自动匹配选择范围为 Drawing，再次点击时则扩展到整个名称。此功能在不同的语言下表现不一。</li>
<li>ctrl+w+t - 列出工程中的任务列表</li>
<li>ctrl+w+c - 开启 Class View，搜索工程中的类</li>
<li>ctrl+f2 - 将光标移动至编辑器上方的导航栏</li>
<li>alt+up/down - 上下移动当前行</li>
</ul>
<h2 id="插件类">插件类</h2>
<h3 id="收费类">收费类</h3>
<ul>
<li>ReSharper - C# 编程必备，绝对神器</li>
<li>Visual Assist X - 支持的语言比 ReSharper 还要多的一个 VS 增强插件</li>
<li>VSCommands - 免费版已经十分实用的插件，暂时还没有在 VS 2012 的添加实用的 File Structure 功能，部分功能可能需要购买授权后才能使用</li>
</ul>
<h3 id="免费类">免费类</h3>
<ul>
<li>Productivity Power Tools - 添加 Ctrl+Click 快捷查询定义、代码地图等功能</li>
<li>NuGet - 不用多说，必装的拓展包管理工具</li>
<li>Code alignment - 使变量声明按照指定规则对齐的插件</li>
</ul>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 2月 4 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/2012-personal-summary.html">2012 年个人小结</a></h1>
  

      <time datetime="2013-01-22T12:55:00.000Z"><a href="/post/2012-personal-summary.html">1月 22 2013</a></time>
      
  </header>
    <div class="entry">
      
        <p>2012 年过得真快，一不小心就走过了世界末日。没有“芥末日”的日子怎么办呢？感觉 2013 的情况并没有比 2012 年好很多，依然有跟不上的感觉。如何让时间多起来？这是一个永恒的话题。下面就稍微总结一下自己的 2012 年吧。</p>
<h2 id="学习">学习</h2>
<p>结束了大学四年的学习，终于开始了新的生活。在大学生活的最后半年里面，总是觉得自己应该赶快脱离学校生活，投入社会生活中。结果刚出来工作半年就感觉还是读书的时候比较好，现在在外面根本没有什么很完整的时间去学习。只有在工作的时候开一下小差，抽点时间做一下自己的事情。</p>
<p>这部分就分上半年和下半年来说吧。</p>
<h3 id="上半年">上半年</h3>
<p>依然在学习网管方面的知识，基本上是为了完成毕业论文里面的内容而翻的书。</p>
<p>看了什么书呢？</p>
<ul>
<li>《Beginning ASP.NET 4 in C# 2010》：一本看了跟没看一样的书，感觉要用这东西还是要实践一下，但是平常自己也没什么需求，于是看了一大半之后发现没什么收获，现在因为基本没有用到所以也忘记得差不多了。</li>
<li>《C# 高级编程》：简单翻了一下，也没有很深入地去看。</li>
<li>《银光志 Silverlight 3.0开发详解与最佳实践》：这书其实应该是上半年的时候看的，基本上是过了一遍，主要是用来实践 WP7 上的开发时看的。</li>
<li>《Windows Phone7 高级编程：使用 VS、Silverlight 与 XNA 进行应用和游戏开发》：这书也是看了一半左右，主要是看了一下后面关于 XNA 开发的内容，但是发现没有多少内容在里面，有点坑爹。</li>
</ul>
<p>翻了一下日志，数下来好像就只有看过这么一两本书了，感觉跟没有看差不多。</p>
<h3 id="下半年">下半年</h3>
<p>下半年其实看的书也不多，但是文档倒是看了一堆，在这里也很难列出来。印象中主要集中看了 DirectX、C++ 和 Python。书也没有看多少内容，因为平常用的地方也不多。于是感觉下半年过得十分快的同时并没有什么技术积累。主要看的也就下面这几本书：</p>
<ul>
<li>《高效能人士的七个习惯》：这书其实是部门经理推荐看的，但是看完之后感觉也没有什么收获，感觉里面的东西其实跟 GTD 差不多。</li>
<li>《Python 基础教程》：这东西其实是年底的时候突然抽风想学的，看了一点点，讲的东西跟自己想做的东西都没有什么很大的交集，主要就只是学习了一些基本的语法之类的，唯一感觉就是在一些字符串之类的处理上很方便。本来想给 Sublime Text 这东西写个简单的插件的，拖几个星期还没有弄完，后文再讲这事吧。</li>
<li>《WPF 编程宝典》：这东西本来就应该是我的主业，结果7月份来了之后就被安排去做内核移植的工作了，期间只有一些零散的时间翻一下这书，只看了前面的一点点东西，写了几个简单的 Demo。对里面的一些事件处理还不熟悉。</li>
</ul>
<p>下半年由于上班了，一开始也不是很适应，于是在刚开始的时候感觉很迷茫（其实现在也好不到哪里去）。后面根据上面的的指示来行动，虽然在工作方面是暂时没有什么问题，但总觉得自己学习的时间和精力也少了很多，静不下心来看书学习（刷微博惹的祸么？）。大量的碎片化阅读导致自己做事的事情也不能长时间地集中精力，经常写一下东西就跑去做其他事，做那么两分钟又回来继续做原来的事情。于是后面主要需要改进的地方就是好好利用手上的工具建立一个属于自己的 GTD 系统（可是我连 GTD 的书都还没有看过，不过已经买了一本了），这个系统后文再说一下。</p>
<p>2012 年里面，书确实读得很少，也读得很零散，基本上没有多少本书是认真过了一遍的。还是需要从根本上提高自己的效率，减少碎片化阅读的时间，增加自己浅阅读乃至深阅读的时间，重新恢复状态。</p>
<h2 id="工作">工作</h2>
<p>关于工作上的事情，这里就不说太多了。除了迷茫还是迷茫，暂时还不知道自己可以做些什么。经常思考一个问题：如果离开了现在这个环境，自己还能不能找到工作？还能不能做出什么东西？如果不能，自己应该怎么做？往哪个方向去做？</p>
<p>工作和学习有点小冲突，但除了改变自己，保持对技术的兴趣，才可以学习到更多的东西。</p>
<h2 id="小创作和任务管理">小创作和任务管理</h2>
<p>其实 2012 年的下半年，我总是想自己去写些什么东西（毕竟自己现在已经是“程序猿”了，虽然我从来不认为自己是一个合格的程序员）。刚开始的时候由于还能跟一下 Windows Phone，于是想写一个简单的 Windows Phone App。后面由于开始工作了之后就没有跟下去了。</p>
<p>然后到后面，一直在搞 C++ 的东西，也没有什么时间去做手机 App 了。一直到现在都没有做出什么像样的东西。</p>
<p>到了 11 月底，终于觉得自己不能再这样了。但是因为自己还真没有什么时间做 App，那段时间用的比较多的却是 <a href="http://www.sublimetext.com/2" target="_blank">Sublime Text 2</a>。于是认真学习了一下 Sublime Text 2 里面的插件，发现里面强大的插件太多了。而且那段时间开始在使用 Markdown 这东西来写东西，渐渐恢复码字的速度。在学习了 Markdown 之后，发现自己写的东西渐渐有点多了，便开始想怎么整理自己的东西。机缘巧合下发现了一个叫 PlainTask 的插件，作为简单的任务管理来说还算是挺实用的。于是开始了一段时间的简单任务管理（具体的经验可以看<a href="http://scriptogr.am/blastmann/post/task-management-in-st2" target="_blank">这篇文章</a>）。</p>
<p>在持续一个多月的 Markdown 写作之后，感觉还是需要把自己写的东西给分享一下，于是找了一些支持 Markdown 格式的博客网站，其实 Wordpress 比较早的时候就已经支持了，但是 GFW 太强，个人暂时也不怎么想搭网站，还是托管到第三方的服务吧。问了一下 Google 发现 <a href="http://scriptogr.am" target="_blank">ScriptOgr.am</a> 这东西还挺简单，挺漂亮的。这网站只负责把 Markdown 格式的文件渲染成 HTML 页面，数据是保存在 Dropbox 上的，所以博客的后台可以用简陋来形容，里面就只有几个简单的功能。博客本身也没有自定义分类、评论功能，只支持添加标签、自定义链接、按时间分类之类的，一切从简，感觉写点小东西是够了。</p>
<p>ScriptOgr.am 上比较有趣的是它开发了些 API，可以让我们自己去做一些小东西来发布文章。突然自己又有了一个需求说是想在 Sublime Text 2 里面写完之后按快捷键直接发布到网站。于是便开始做自己的第一个基于 Sublime Text 2 的小东西：ScriptOgrSender。但是这东西写了半天还没有搞好线程处理、AppID加密之类的东西，一直没有时间去继续测试，只好暂时放着。反正 Mou 这东西还可以用一下，即使是文章发布也可以直接扔 Dropbox 上同步一下就完成了。</p>
<p>怎么说呢，在 2012 年结束之前还算是有点小收获吧。</p>
<h2 id="展望_2013">展望 2013</h2>
<p>2013 年最想做些什么呢？暂时还没有想到，感觉自己的需求都是一些很小的需求，要不就花钱可以解决，要不就是不解决也不会死的。</p>
<p>不过还是得简单展望一下 2013 年：</p>
<ul>
<li>真正有自己的作品</li>
<li>基本学会 WinRT</li>
<li>保持良好的学习状态</li>
<li>考一个证</li>
</ul>
<p>最后，祝春节快乐。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 1月 22 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/my-st2-tips.html">Sublime Text 使用技巧总结</a></h1>
  

      <time datetime="2013-01-16T00:00:00.000Z"><a href="/post/my-st2-tips.html">1月 16 2013</a></time>
      
  </header>
    <div class="entry">
      
        <h2 id="Sublime_Text_使用技巧总结">Sublime Text 使用技巧总结</h2>
<p>简单总结一下 ST2 在使用过程中的一些小经验和技巧吧。</p>
<h2 id="亮点功能">亮点功能</h2>
<ul>
<li>在工程项目中的快速文件切换</li>
<li>当前文件中的函数定位</li>
<li>支持插件功能</li>
<li>自定义Snippet支持</li>
<li>免打扰模式</li>
<li>Mac 版本下支持 TextMate 的 Bundle</li>
</ul>
<h2 id="快捷键">快捷键</h2>
<p>关于软件中的快捷键，其实可以自行查找软件中的快捷键设定文件（ Preferences-&gt;Key Binding - Default ），打开之后可以看到一堆快捷键绑定。</p>
<p>简单解释一下配置文档中的快捷键绑定，super 键就是对应 Windows 下面的 win 键，在 OSX 下面对应的是 command 键。一部分键位组合在 Windows 下面并不能使用，例如 super+1,2,3,4,5… 之类当前打开文件切换的快捷键（由于会与系统快捷键产生冲突），所以会更改为 alt+1,2,3,4,5… 等。</p>
<h3 id="基本操作">基本操作</h3>
<p>简单列出一些常用的快捷键吧。</p>
<ul>
<li>ctrl+shift+p - 调出全局功能菜单，支持模糊匹配，可以直接输入菜单中的命令的部分字母直接调用。</li>
<li>ctrl+p - 打开快速文件切换面板（可以同时使用组合命令如 <code>:</code> 和 <code>@</code> 这两个命令）</li>
<li>ctrl+tab - 按照打开顺序切换当前打开的文件</li>
<li>ctrl+t - 新建一个tab</li>
<li>ctrl+w - 关闭当前tab</li>
<li>ctrl+shift+t - 恢复关闭的tab</li>
<li>ctrl+d - 选中当前的单词</li>
<li>ctrl+l - 选中当前的行</li>
<li>ctrl+m - 移动光标到作用域中括号</li>
<li>ctrl+shift+m - 选中光标所在位置到框选部分</li>
<li>ctrl+k, ctrl+b - 显示、关闭侧边栏</li>
</ul>
<h3 id="其他较好用的快捷键">其他较好用的快捷键</h3>
<ul>
<li>ctrl+super+g - 快速在当前文档中查找选中部分并全部选中，支持同时编辑</li>
<li>alt+super+g - 快速向下查找下一项</li>
<li>ctrl+shift+up/down - 将当前行或选中的部分向上/向下移动一行</li>
</ul>
<h2 id="Package_Control_—_最重要的插件管理工具">Package Control — 最重要的插件管理工具</h2>
<h3 id="如何为Sublime_Text添加Package_Control？">如何为Sublime Text添加Package Control？</h3>
<p>Sublime Text的软件架构支持添加插件，但是我们仍然需要一个方便的管理工具来管理我们的Package，此时我们就需要使用<a href="http://wbond.net/sublime_packages/package_control" target="_blank">Package Control</a>。</p>
<h4 id="自动安装">自动安装</h4>
<p>按组合键Ctrl+`打开Console，然后添加下面的命令：</p>
<pre><code>import urllib2,os; pf=<span class="string">'Package Control.sublime-package'</span>; ipp=sublime.installed_packages_path(); os.makedirs(ipp) <span class="keyword">if</span> <span class="keyword">not</span> os.path.<span class="keyword">exists</span>(ipp) <span class="keyword">else</span> None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); <span class="keyword">open</span>(os.path.<span class="keyword">join</span>(ipp,pf),<span class="string">'wb'</span>).<span class="keyword">write</span>(urllib2.urlopen(<span class="string">'http://sublime.wbond.net/'</span>+pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).<span class="keyword">read</span>()); <span class="keyword">print</span> <span class="string">'Please restart Sublime Text to finish installation'</span>
</code></pre><p>最新版本的Package Control已经完善了网络代理的功能，因此如果使用时的网络环境处于代理环境下，我们可以通过修改Package Control的配置文件来添加代理服务器地址。</p>
<h4 id="手动安装">手动安装</h4>
<ol>
<li>点击<em>Preference &gt; Browse Packages..</em></li>
<li>打开<em>Installed Packages</em>目录</li>
<li><a href="http://sublime.wbond.net/Package%20Control.sublime-package" target="_blank">点击下载</a>并将文件复制到’Installed Packages’目录下</li>
<li>重启Sublime Text</li>
</ol>
<h4 id="如何使用">如何使用</h4>
<p>Package Control安装完成之后，会在软件全局菜单（Ctrl+Shift+p）添加相应的菜单项，我们只需调出菜单，输入pci(Package Control: Install Package，对应命令中握住的字母)，即可开始安装我们需要的插件。</p>
<h3 id="强大的插件">强大的插件</h3>
<p>下面推荐的插件都可以直接在 Package Control 里面安装，很是方便。</p>
<ul>
<li>Zen Coding / Emmet - Zen Coding是前端工程师必备快速书写 HTML 代码的插件，后来改名为 Emmet。具体可以参考 <a href="http://docs.emmet.io/" target="_blank">doc.emmet.io</a></li>
<li>SublimeLinter - 用于检查代码书写是否正确的插件，并给出相应的修改提示，支持 C/C++、CSS、HTML、Javascript、Perl、XML 等语言，在使用 Package Control 安装完成后，请参考插件目录下面的 Readme.md 进行相应配置。详情可以<a href="https://github.com/SublimeLinter/SublimeLinter" target="_blank">点击这里</a>。</li>
<li>Sublime Alignment - 让你的变量赋值代码自动对齐</li>
<li>Clipboard History - 添加剪切板历史功能</li>
<li>Sublime CodeIntel - 添加智能提示功能</li>
<li>ConvertToUTF8 - ST2 只支持 UTF8 编码。此插件可以让 ST2 支持显示 GBK，BIG5 等编码的显示</li>
<li>Http Requester - 使用选中的超链接快速发出一个 HTTP 请求并将返回结果显示在当前文件中</li>
<li>Sublime V8 - 使用 V8 引擎调试当前的 JS 代码</li>
</ul>
<h2 id="设置">设置</h2>
<p>在 Preferences-&gt;Settings - Defaults 可以找到软件默认的设置选项，需要注意一点：标明 Defaults 的文件在软件升级的时候一般都会被覆盖。建议将需要修改的选项添加到 Settings - User中，避免在升级过程中被覆盖。</p>
<p>下面是我个人的一个喜好设置，其中的一些设置选项可以参考下面的注释。</p>
<pre><code>{
    <span class="comment">// 设置自动完成的延时</span>
    <span class="string">"auto_complete_delay"</span>: <span class="number">500</span>,
    <span class="comment">// 默认配色主题</span>
    <span class="string">"color_scheme"</span>: <span class="string">"Packages/Color Scheme - Default/Monokai Bright.tmTheme"</span>,
    <span class="comment">// 检查缩进</span>
    <span class="string">"detect_indentation"</span>: <span class="keyword">true</span>,
    <span class="comment">// 检查启动太慢的插件</span>
    <span class="string">"detect_slow_plugins"</span>: <span class="keyword">false</span>,
    <span class="comment">// 字体选择</span>
    <span class="string">"font_face"</span>: <span class="string">"Monaco"</span>,
    <span class="comment">// 字体大小</span>
    <span class="string">"font_size"</span>: <span class="number">12</span>,
    <span class="comment">// 忽略插件</span>
    <span class="string">"ignored_packages"</span>:
    [
        <span class="string">"Vintage"</span>
    ],
    <span class="comment">// tab大小设置</span>
    <span class="string">"tab_size"</span>: <span class="number">4</span>,
    <span class="comment">// 将tab转换为空格</span>
    <span class="string">"translate_tabs_to_spaces"</span>: <span class="keyword">true</span>,
    <span class="comment">// 自动删除空白位置</span>
    <span class="string">"trim_automatic_white_space"</span>: <span class="keyword">true</span>,
    <span class="comment">// 保存时删除每行结束后面多余的空格</span>
    <span class="string">"trim_trailing_white_space_on_save"</span>: <span class="keyword">true</span>
}
</code></pre><h2 id="Key_Bindings">Key Bindings</h2>
<p>Key Bindings 是 ST2 中的快捷键绑定设置文件，内容很清晰易懂。Key Bindings 中提供了很多设置的组合选项，可以对不同条件下面的情况进行快捷键绑定。</p>
<pre><code>[
    // 将 f12 绑定为 ReIndent 命令，自动重新缩进代码（支持HTML与CSS）
    { "<span class="attribute">keys</span>": <span class="value">[<span class="string">"f12"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"reindent"</span></span>, "<span class="attribute">args</span>": <span class="value">{"<span class="attribute">single_line</span>": <span class="value"><span class="literal">false</span></span>} </span>},
    // 除了支持命令绑定参数，还支持定义上下文，只有符合定义上下文中的情况下才启动对应快捷键
    { "<span class="attribute">keys</span>": <span class="value">[<span class="string">"super+shift+m"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"plain_tasks_cancel"</span></span>, "<span class="attribute">context</span>": <span class="value">[{"<span class="attribute">key</span>": <span class="value"><span class="string">"selector"</span></span>, "<span class="attribute">operator</span>": <span class="value"><span class="string">"equal"</span></span>, "<span class="attribute">operand</span>": <span class="value"><span class="string">"text.todo"</span> </span>}] </span>}
]
</code></pre><h2 id="Snippets_代码片段定义">Snippets 代码片段定义</h2>
<p>在 ST2 的菜单中可以自行新建一个属于自己的 Snippet，可以将常用的代码片段放置在其中，只要输入自己定义的字符，点击 tab 键便自动拓展其内容。</p>
<p>在 Tools 菜单下点击 New Snippet，自动弹出下面的示例内容。</p>
<pre><code><span class="tag">&lt;<span class="title">snippet</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="cdata">&lt;![CDATA[
Hello, ${1:this} is a ${2:snippet}.
]]&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
    <span class="comment">&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</span>
    <span class="tag">&lt;<span class="title">tabTrigger</span>&gt;</span>hello<span class="tag">&lt;/<span class="title">tabTrigger</span>&gt;</span>
    <span class="comment">&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</span>
    <span class="comment">&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span>
<span class="tag">&lt;/<span class="title">snippet</span>&gt;</span>
</code></pre><p>去掉 tabTrigger 注释保存之后，在文档中输入 hello+tab 便会自动输出对应的 snippet 内容，并提供两个点击 tab 后切换的编辑点。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 1月 16 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/procedure-of-directx-display.html">DirectX显示流程学习小结</a></h1>
  

      <time datetime="2013-01-09T00:00:00.000Z"><a href="/post/procedure-of-directx-display.html">1月 9 2013</a></time>
      
  </header>
    <div class="entry">
      
        <p>下面说一下近来对DX学习的一些自己的理解，不对的地方请提出。下面部分内容可以直接到微软WP8开发者页面查询，<a href="http://msdn.microsoft.com/zh-cn/library/windowsphone/develop/jj714079(v=vs.105" target="_blank">点击链接</a>.aspx)。</p>
<h2 id="无法正常显示图像的原因">无法正常显示图像的原因</h2>
<ul>
<li>设备初始化过程中出现异常</li>
<li>三种视图初始化或设置错误</li>
<li>着色器编写错误</li>
<li>纹理资源视图设置</li>
<li>二维投影视图设置与三维投影视图设定时，位图顶点缓存位置设置的区别</li>
<li>交换链创建时，建议交换链创建时缓存结构格式使用 <code>DXGI_FORMAT_B8G8R8A8_UNORM</code> 。在调用 <code>D3D11CreateDeviceAndSwapChain</code> 或者 <code>D3D11CreateDevice</code> 的时候，添加 <code>D3D11_CREATE_DEVICE_BGRA_SUPPORT</code> 的标志选项。</li>
<li>注意纹理生成时的格式处理（ <code>DXGI_FORMAT_B8G8R8A8_UNORM</code> 与 <code>DXGI_FORMAT_R8G8B8A8_UNORM</code> 的区别），BGRA与RGBA的区别将造成红蓝两色相反</li>
</ul>
<p>基本上DX的使用过程中需要注意的地方都是一些小细节问题，稍微出现一点点差错就会造成图像无法显示、显示错误之类的问题，而且比较多的时候都不会有</p>
<h2 id="桌面DirectX程序与WP8上的DirectX_Component之间的区别">桌面DirectX程序与WP8上的DirectX Component之间的区别</h2>
<p>桌面程序中仍然需要绑定HWND等句柄。内容刷新过程可以使用WM_PAINT、ValidateRect和InvalidateRect等传统的窗体消息循环过程。通过WM_PAINT消息通知DirectX组件进行初始化及屏幕刷新等信息。不使用WM_PAINT消息循环亦可，但需要在DX中自行处理消息响应。</p>
<p>使用DirectX的原因是由于WP8系统上不支持传统的GDI函数，无法直接进行屏幕显示内容的刷新。</p>
<p>WP8上使用DirectX Component则与上述流程有所不同。注意以下几点：</p>
<ul>
<li>WP8上的DX Component，需要与XAML中的DrawingSurfaceBackgroundGrid或DrawingSurface这两个控件进行绑定。</li>
<li>绑定控件后，两种控件都会有不同的接口需要实现。（<a href="#dxctrlapi">后续列出</a>）</li>
<li>两种控件的绑定过程中，DX设备与交换链中的初始化过程不一样，前者将不需要自行初始化交换链，性能更好。</li>
<li>桌面程序中可以调用的DX接口更丰富，WP8中的部分接口实现需要重新封装成异步操作，提高UI的响应效率。</li>
<li>HLSL编写的着色器程序，在WP8编译过程中需要使用编译器对其进行处理，桌面程序则可以在应用程序启动的时候使用相应的API（<code>D3DX11CompileFromFile</code>）进行编译。性能自然是前者更好，因此仍然需要重新编写测试工程中的DX组件。</li>
<li>桌面程序的窗口大小可变，WP8上的应用窗口大小不可变，两者之间的区别会影响DX组件中对交换链的创建处理、纹理大小的创建之类的问题。这也是为何桌面上的游戏程序一般均进行窗口大小锁定，避免Resize过程对显示内容造成影响。</li>
<li>桌面上的DX在初始化的过程中需要检查显卡支持的分辨率，在创建过程需要注意窗口的大小是否符合显卡的大小。当然，我们可以固定创建一个分辨率固定的设备，在纹理生成过程通过更改纹理的顶点缓存位置进行显示区域的修改。在WP8上不需要注意此过程。</li>
<li>WP8的DX组件需要通过复制”同步纹理“来更新显示内容，此接口可以处理为死循环，则会实现高性能屏幕输出，但CPU占用率较高。可以根据自己的需要来修改相应的循环过程。</li>
</ul>
<h2 id="接口代码_">接口代码 <a id="dxctrlapi"></a></h2>
<p>下面的DX接口代码可以在<code>DrawingSurfaceNative.h</code>头文件中查询。</p>
<h5 id="DrawingSurfaceBackgroundGrid:">DrawingSurfaceBackgroundGrid:</h5>
<pre><code>IDrawingSurfaceBackgroundContentProviderNative : <span class="keyword">public</span> IUnknown
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">Connect</span>( 
        /* [annotation][<span class="keyword">in</span>] */ 
        _In_  IDrawingSurfaceRuntimeHostNative *host,
        /* [annotation][<span class="keyword">in</span>] */ 
        _In_  ID3D11Device1 *hostDevice) = <span class="number">0</span>;

    <span class="keyword">virtual</span> <span class="keyword">void</span> STDMETHODCALLTYPE Disconnect( <span class="keyword">void</span>) = <span class="number">0</span>;

    <span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE PrepareResources( 
        <span class="comment">/* [annotation][in] */</span> 
        _In_  <span class="keyword">const</span> LARGE_INTEGER *presentTargetTime,
        <span class="comment">/* [annotation][in][out] */</span> 
        _Inout_  DrawingSurfaceSizeF *desiredRenderTargetSize) = <span class="number">0</span>;

    <span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE Draw( 
        <span class="comment">/* [annotation][in] */</span> 
        _In_  ID3D11Device1 *hostDevice,
        <span class="comment">/* [annotation][in] */</span> 
        _In_  ID3D11DeviceContext1 *hostDeviceContext,
        <span class="comment">/* [annotation][in] */</span> 
        _In_  ID3D11RenderTargetView *hostRenderTargetView) = <span class="number">0</span>;

};
</code></pre><h5 id="DrawingSurface:">DrawingSurface:</h5>
<pre><code>IDrawingSurfaceContentProviderNative : <span class="keyword">public</span> IUnknown
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="title">Connect</span>( 
        /* [annotation][<span class="keyword">in</span>] */ 
        _In_  IDrawingSurfaceRuntimeHostNative *host) = <span class="number">0</span>;

    <span class="keyword">virtual</span> <span class="keyword">void</span> STDMETHODCALLTYPE Disconnect( <span class="keyword">void</span>) = <span class="number">0</span>;

    <span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE PrepareResources( 
        <span class="comment">/* [annotation][in] */</span> 
        _In_  <span class="keyword">const</span> LARGE_INTEGER *presentTargetTime,
        <span class="comment">/* [annotation][out] */</span> 
        _Out_  BOOL *isContentDirty) = <span class="number">0</span>;

    <span class="keyword">virtual</span> HRESULT STDMETHODCALLTYPE GetTexture( 
        <span class="comment">/* [annotation][in] */</span> 
        _In_  <span class="keyword">const</span> DrawingSurfaceSizeF *surfaceSize,
        <span class="comment">/* [annotation][out] */</span> 
        _Outptr_  IDrawingSurfaceSynchronizedTextureNative **synchronizedTexture,
        <span class="comment">/* [annotation][out] */</span> 
        _Out_  DrawingSurfaceRectF *textureSubRectangle) = <span class="number">0</span>;

};
</code></pre><p>上述的接口代码中可以看到两者的区别比较明显的是：DSBG控件将由系统创建DX设备、设备上下文、RenderTargetView资源视图。而DrawingSurface则只会负责传入控件的大小和同步纹理（SynchronizedTexture），其他DX所需的资源将要由我们自行创建。但需要注意的是，即使是使用DSBG，我们也可以使用自行创建的设备，具体可以参考HybridMarbleMaze这个示例游戏，游戏对比了两种控件的效率，后者效率仅为前者的2/3。</p>
<h2 id="DirecXHelper-h">DirecXHelper.h</h2>
<p>此文件封装了一部分WP8平台上文件读取和错误信息抛出的函数，帮助我们更方便地创建异步操作。</p>
<pre><code><span class="preprocessor">#pragma once</span>
<span class="preprocessor">#include &lt;wrl/client.h&gt;</span>
<span class="preprocessor">#include &lt;ppl.h&gt;</span>
<span class="preprocessor">#include &lt;ppltasks.h&gt;</span>
<span class="preprocessor">#include &lt;memory&gt;</span>

<span class="keyword">namespace</span> DX
{
    <span class="keyword">inline</span> <span class="keyword">void</span> ThrowIfFailed(HRESULT hr)
    {
        <span class="keyword">if</span> (FAILED(hr))
        {
            <span class="comment">// Set a breakpoint on this line to catch DirectX API errors</span>
            <span class="keyword">throw</span> Platform::Exception::CreateException(hr);
        }
    }

    <span class="keyword">struct</span> ByteArray { Platform::Array&lt;byte&gt;^ data; };

    <span class="comment">// function that reads from a binary file asynchronously</span>
    <span class="keyword">inline</span> Concurrency::task&lt;ByteArray&gt; ReadDataAsync(Platform::String^ filename)
    {
        <span class="keyword">using</span> <span class="keyword">namespace</span> Windows::Storage;
        <span class="keyword">using</span> <span class="keyword">namespace</span> Concurrency;
        <span class="keyword">auto</span> folder = Windows::ApplicationModel::Package::Current-&gt;InstalledLocation;
        task&lt;StorageFile^&gt; getFileTask(folder-&gt;GetFileAsync(filename));
        <span class="comment">// Create a local to allow the DataReader to be passed between lambdas.</span>
        <span class="keyword">auto</span> reader = <span class="built_in">std</span>::make_shared&lt;Streams::DataReader^&gt;(<span class="keyword">nullptr</span>);
        <span class="keyword">return</span> getFileTask.then([](StorageFile^ file)
        {
            <span class="keyword">return</span> file-&gt;OpenReadAsync();
        }).then([reader](Streams::IRandomAccessStreamWithContentType^ stream)
        {
            *reader = ref <span class="keyword">new</span> Streams::DataReader(stream);
            <span class="keyword">return</span> (*reader)-&gt;LoadAsync(<span class="keyword">static_cast</span>&lt;uint32&gt;(stream-&gt;Size));
        }).then([reader](uint32 count)
        {
            <span class="keyword">auto</span> a = ref <span class="keyword">new</span> Platform::Array&lt;byte&gt;(count);
            (*reader)-&gt;ReadBytes(a);
            ByteArray ba = { a };
            <span class="keyword">return</span> ba;
        });
    }
}
</code></pre><p>ReadDataAsync函数是示例工程中提供的用于异步读取着色器编译后的cso文件的接口，当然也可以用于其他地方的文件读取。只需要简单地将文件读取调用封装成Task即可。</p>
<h2 id="XAML中的D3D">XAML中的D3D</h2>
<p>下面摘录一部分来自微软官网的文档：</p>
<p>每次 XAML 引擎更新 XAML UI 时，它都会调用 Draw 方法。当前帧完成后，对 RequestAdditionalFrame 的调用将立即请求 XAML 引擎重新绘制屏幕。要降低应用的耗电量，您可以修改模板代码，以便每次调用 Draw 方法时不会调用 RequestAdditionalFrame。每次更新 UI 时，XAML 引擎仍然调用 Draw，但它不会立即尝试重新绘制。当应用显示不需要在尽可能最高的帧速率下进行重新绘制的静态内容时，这特别有用。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 1月 9 2013</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/notes-of-my-python-learning-01.html">Python简明教程学习笔记一</a></h1>
  

      <time datetime="2012-12-27T15:37:00.000Z"><a href="/post/notes-of-my-python-learning-01.html">12月 27 2012</a></time>
      
  </header>
    <div class="entry">
      
        <p>刚刚开始学习Python，主要还是从基础概念入手，实则这些东西每种语言都是差不多的，不过感觉还是需要学习一门比较简单的脚本语言。下面就列一下一些基本概念吧。</p>
<h2 id="基本概念">基本概念</h2>
<h3 id="字面意义上的常量">字面意义上的常量</h3>
<p>即一般的常量，只代表它自己。</p>
<h3 id="数">数</h3>
<ul>
<li>整数</li>
<li>长整数</li>
<li>浮点数</li>
<li>复数</li>
</ul>
<h3 id="字符串">字符串</h3>
<ul>
<li>单引号与双引号结果的使用是一样的</li>
<li>三引号’’’或”””，可以指示一个多行的字符串</li>
<li>转义符：利用反斜杠\来转义</li>
<li>自然字符串：在字符串前添加r或者R，则其中的内容都无须转义</li>
<li>Unicode字符串：在字符串前添加u或者U</li>
<li>字符串与常量一样，不可变</li>
</ul>
<h3 id="变量">变量</h3>
<p>变量，计算机中存储信息的一部分内存。访问的时候需要给变量命名。</p>
<h3 id="标识符的命名">标识符的命名</h3>
<ul>
<li>标识符的第一个字符必须是字母表中的字母（大小写）或者下划线_</li>
<li>标识符名称的其他部分可以由字母（大小写）、下划线或数字组成</li>
<li>标识符名称对大小写敏感</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>变量可以处理不同类型的值，称为数据类型。</p>
<h3 id="对象">对象</h3>
<p>Python中所有东西都是对象。</p>
<h3 id="逻辑行与物理行">逻辑行与物理行</h3>
<p>Pythone中假定每个<em>物理行</em>对应一个<em>逻辑行</em>。如果想要在一个物理行中使用多于一个逻辑行， 那么需要使用分号来特别地标明这种用法。分号表示一个逻辑行/语句的结束。</p>
<h3 id="缩进">缩进</h3>
<p>空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。</p>
<p>这意味着同一层次的语句必须有相同的缩进。每一组这样的语句称为一个块。我们将在后面的章节中看到有关块的用处的例子。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 12月 27 2012</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"><a href="/post/texture-addressing-modes.html">Texture Addressing Modes（纹理地址模式）</a></h1>
  

      <time datetime="2012-12-26T04:16:00.000Z"><a href="/post/texture-addressing-modes.html">12月 26 2012</a></time>
      
  </header>
    <div class="entry">
      
        <p>Direct3D中的纹理都是位图，所以任何位图数据都可以赋予给一个Direct3D原始数据。除此之外，D3D还可以支持更多的高级渲染技术，例如纹理混合和光源映射。想得到更多相关的信息，可以参阅<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb206241(v=vs.85" target="_blank">Texture Blending</a>.aspx)和<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb174695(v=vs.85" target="_blank">Light mapping with Textures</a>.aspx)。</p>
<p>如果你的应用程序创建了一个HAL（硬件抽象层）设备或者一个软设备，则可以使用8/16/24/32/64或者128位的纹理。</p>
<h2 id="Texture_Addressing_Modes（纹理地址模式）">Texture Addressing Modes（纹理地址模式）</h2>
<h3 id="Wrap_Texture_Address_Mode">Wrap Texture Address Mode</h3>
<h3 id="Mirror_Texture_Address_Mode">Mirror Texture Address Mode</h3>
<h3 id="Clamp_Texture_Address_Mode">Clamp Texture Address Mode</h3>
<h3 id="Border_Color_Texture_Address_Mode">Border Color Texture Address Mode</h3>
<h2 id="Texture_Dirty_Regions（纹理污染区域）">Texture Dirty Regions（纹理污染区域）</h2>
<p>通过指定纹理中的污染区域，应用程序可以只更新纹理中的部分区域。只有被标明为污染的区域才会调用<code>IDirect3DDevice9::UpdateTexture</code>来拷贝更新区域。然而，污染区域的声明还需要考虑对齐优化的问题。当纹理创建完成后，整个纹理都会被认为是受污染的（脏的）。只有下面的操作会影响纹理的污染状态：</p>
<ul>
<li>在纹理中添加一个污染区域</li>
<li>锁定部分纹理缓存，此操作将自动添加锁定区域为污染区域</li>
<li>在<code>IDirect3DDevice9::UpdateSurface</code>中使用表面级别的纹理作为目标纹理</li>
<li>在<code>IDirect3DDevice9::UpdateTexture</code>中将纹理作为源，用来清除源纹理中的污染区域</li>
<li>使用<code>IDirect3DSurface9::GetDC</code>来返回设备上下文</li>
</ul>
<p>因为每种纹理都有不同类型的污染区域，所以各个纹理类型都有相应的方法取得相应的信息。</p>
<ul>
<li><code>IDirect3DCubeTexture9::AddDirtyRect</code></li>
<li><code>IDirect3DTexture9::AddDirtyRect</code></li>
<li><code>IDirect3DVolumeTexture9::AddDirtyBox</code> </li>
</ul>
<p>当使用<code>NULL</code>作为<code>pDirtyRect</code>或者<code>pDirtyBox</code>作为参数传入上述方法中时，污染区域将会扩展覆盖至整个纹理。</p>
<p>每个锁定方法都可以传入<code>D3DLOCK_NO_DIRTY_UPDATE</code>用于防止纹理的污染状态改变。<br>详情可以参阅<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb174707(v=vs.85" target="_blank">Locking Resource</a>.aspx)。</p>
<h2 id="Texture_Palettes（纹理调色板）">Texture Palettes（纹理调色板）</h2>
<p>D3D9支持对纹理进行调色。在<code>IDirect3DDevice9</code>对象中，有一套256色的调色板。可以通过<code>IDirect3DDevice9::SetCurrentTexturePalette</code>设置当前的调色板属性。</p>

	 
	     <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="http://weibo.com/newdings/"><strong>@cmm要给力</strong></a> - 12月 26 2012</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://blog.edi-c.com"><strong>@chaoming.edc blog</strong></a></span>
</p>
       	 
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/5/" class="alignright next">下一页</a>
  
</nav></div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="/about/">About</a></div>
    
      <div class="tabbaritem"><a class="next" href="/atom.xml">Subscribe</a></div>
    
</div>


  </div>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.min.js"></script>
</body>
</html>