date: 2013-03-24 11:54
title: 关于 WPF 中的面板性能分析  
permalink: wpf-panels-performance
tags: WPF
---

资料来源：[In what order are Panels the most efficient in terms of render time and performance?](http://stackoverflow.com/questions/9946811/in-what-order-are-panels-the-most-efficient-in-terms-of-render-time-and-performa)

以下内容为答案的翻译，如有翻译不当的地方，请指正：

我认为，比起直接给出这些控件的性能比较结论，更好的是准确地去理解每个面板控件自身的性能特性。WPF 在绘制内容的时候，需要经过两个步骤：*计算*和*排列*。每种面板在这两个不同的阶段里面都有不同的性能特性。

在*计算*这个步骤里面，影响性能的是面板是否具有自适应的排列特性（例如在水平对齐的属性中使用 `Strech` 或者 `Grid` 中使用 `Auto`），如有设置，则它的子控件都将会拉伸或者自动计算大小。而在*排列*这个步骤里面，影响性能的是不同的子控件在布局位置之间的相互作用的复杂度以及子控件的数目。

有时候，原生的面板控件并不方便做成我们想要的布局。我开发过一个控件，它可以指定子控件在开用空间内占据的位置的百分比。在所有默认的控件中，没有一个可以达到这样的效果。如果真想使用默认控件（通过绑定父控件的实际大小），将会得到糟糕的性能表现。于是我创建了一个继承自 `Canvas` 的布局面板控件来达到我想要的效果（我在 `Canvas` 控件的源码中修改了大概20行左右，便完成了）。

下面讨论一下 WPF 中可用的面板控件：

### `Canvas`

> 它定义了一个区域，你将可以显式地指定子元素相对于 Canvas 区域的坐标

`Canvas` 拥有在所有控件中最好的*排列*性能，因为它所有的子控件位置都是固定的、直接指定的。在*计算*步骤中，它也有很好的性能表现，原因是它并没有拉伸的属性，所有的子元素都是使用自己的原始大小。评估：性能最好，无论是计算性能和排列性能。

### `DockPanel`

> 它定义了一个区域，你可以将子元素以水平或垂直方向排列。

`DockPanel` 的布局策略十分简单，所有加入它内部的项目将逐个按顺序排列。默认地，它的大小将由子项目的原始大小来决定（基于顶部/底部和左边/右边的相对位置），如果宽高没有定义的话，对应方向的大小则将 `Dock` 属性来决定。评估：它的计算性能和排列性能都属于中等水平。

### `Grid`

> 它定义了一个灵活的网格区域，可以分割成多行与多列

如果使用按比例或者全自动调节界面大小的话，`Grid` 是一个性能损耗最严重的面板控件。原因是：当子项目的原始大小和布局位置通过 `Grid` 来指定的时候，子项目的大小计算是一件十分复杂的事情。同时，在所有面板控件中，它的布局过程是最复杂的。评级：它的计算性能和排列性能属于中低水平。

### `StackPanel`

> 它定义了一个区域，区域内的子元素将按照水平方向或垂直方向排列成一行

在 `StackPanel` 内，子元素的大小将如此计算：根据 `StackPanel` 的排列方向，如：垂直方向，则它的子元素在水平方向的大小则使用原始大小或相对大小，而垂直方向的大小则使用原始大小（对齐属性在此方向并不影响它的大小）。这将使 `StackPanel` 拥有一个中等级别的性能。由于它的排列步骤相对简单，只是将子元素按顺序的逐个排列，所以它在这步骤的性能在所有面板控件中估计能排到第二名。评级：它的计算性能属于中等水平，排列性能属于高等水平。

### `VirtualizingPanel`

> 它提供了一个框架，让面板元素可以虚拟化它们的子元素数据集合。这是一个抽象类。

如果你需要自己实现一个虚拟化面板，你将需要使用这个基类。它只会加载可视项目的数据，防止内存和 CPU 不必要使用。由于只会显示项目集的一部分，因此性能也较好。影响性能的地方估计就在让项目显示的时候需要对显示区域的边界进行检查。在 SDK 中只提供了一个它的子类：`VirtualizingStackPanel`。

### `WrapPanel`

> 它提供了一个区域，子元素从左到右地排列在连续的位置中，如果到达了面板的边界，则元素的位置将换行显示。根据排列方向的属性定义，元素显示排列可以是从上到下或者从右到左。

`WrapPanel` 的计算步骤是一个复杂的过程，它的行高可以由行的原始高度或者行中的某个子元素的高度来决定，视乎于哪个的高度比较大，最大的将决定行高。排列步骤则相对简单，只需要将子元素按顺序逐个放置即可，如空间不足则自动换行。评估：`WrapPanel` 拥有中等水平的计算性能和排列性能。

## 参考资料

*  **[尽可能使用最高效的面板](http://msdn.microsoft.com/zh-cn/library/bb613542.aspx)**：
> 布局过程的复杂性直接取决于您使用的 Panel 派生元素的布局行为。 例如，Grid 或 StackPanel 控件提供的功能比 Canvas 控件多很多。 功能大大提高的代价是性能成本也大大提高。 但是，如果您不需要 Grid 控件提供的功能，则应使用成本较低的其他控件，如 Canvas 或自定义面板。

*  [测量和排列子控件](http://msdn.microsoft.com/zh-cn/library/ms745058.aspx#LayoutSystem_Measure_Arrange)